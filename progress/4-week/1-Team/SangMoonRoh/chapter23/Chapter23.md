# 자바랭 다음으로 많이 쓰는 애들은 컬렉션 - Part2(Set 과 Queue)

## Set이 왜 필요하지?
- Collection을 확장한 배열과 비슷한 역할을 하는 3개의 인터페이스 List, Set, Queue
  - List는 순서가 중요한 데이터를 담을 때 사용
  - Set 은?
    - 순서에 상관없이 어떤 데이터가 존재하는지를 확인하기 위한 용도로 많이 사용된다.
    - 중복 방지/ 원하는 값 포함 여부 확인이 주용도.
      - ex ) 어떤 서버에 1분간 사용자가 요청한 로그가 있다.  
      이 서버에 붙어서 요청한 IP를 기준으로 사용자의 수가 얼마나 되는지 확인한다고 가정해보면,  
      1분간 동일한 서버에 요청하는 중복 사용자 수는 매우 많다. 이러한 경우에 만약 앞 장에서배운 배열로 확인하게 되면   
      indexOf()라는 메서드로 해당 객체가 존재하는지 확인 후 add() 메서드로 추가하는 작업을 반복해야만 한다.  
      하지만 Set 을 구현한 클래스를 사용하면 그냥 데이터를 추가만 해주면 중복되지 않고 저장된다.
      - HashSet의 예제
        - Set인터페이스를 구현한 주요 클래스는 HashSet, TreeSet, LinkedHashSet이 있다.
          - HashSet : 순서가 전혀 필요 없는 데이터를 해시 테이블 `hashTable`에 저장한다. Set중에 가장 성능이 좋다.
          - TreeSet : 저장된 데이터의 값에 따라서 정렬되는 셋이다. red-black 이라는 트리 타입으로 값이 저장된다. HashSet보다 약간 성능이 느리다.
          - LinkedHashSet : 연결된 목록 타입으로 구현된 해시 테이블에 데이터를 저장한다.
          - 저장된 수너에 따라 값이 정렬된다. 대신 성능이 가장 나쁨.
        - 성능 차이는 데이터 정렬 때문이다. HashSet은 별도의 정렬 작업이 없어 제일 빠르다.
        - red-black 트리는 가 노드의 색을 붉은 색 혹은 검은색으로 구분하여 데이터를 빠르고 쉽게 찾을수 있는 구조의 이진트리 ` 자가 균형 (높이 균형) 이진 탐색 트리`를 말한다.

### HashSet ? 
- HashSet 클래스의 상속 관계
```java
java.lang.Object
 - java.util.AbstractCollection<E>
    - java.util.AbstractSet<E>
        - java.util.HashSet<E>
```

- `AbstractCollection`을 확장한 것은 ArrayList와 동일하다.
- HashSet은 AbstractSet을 확장했다.
  - AbstractSet 클래스는 이름 그대로 abstract 클래스이다.
  - 구현되어 있는 메서드는 Object 클래스에 선언되어 있는 equals(), hashCode() 메서드와 이 클래스에서 추가한 removeAll()뿐이다.
  - Set은 무엇보다도 데이터가 중복되는 것을 허용하지 않는다. 데이터가 같은지를 확인하는 작업은 Set의 핵심.
    - equals()메서드와 hashCode() 메서드와 떨어질수 없는 불가분의 관계이다.
    - equals() 와 hashCode() 메서드를 구현하는 부분은 Set에서 매우 중요하다.
    - 추가로 removeAll() 메서드는 컬렉션을 매개 변수로 받아, 매개 변수 컬렉션에 포함된 모든 데이터를 지울 때 사용한다.
    - 상속 관계를 간단히 살펴보았으니, HashSet이 어떤 인터페이스를 구현했는가.
    - |인터페이스| 용도                                                         |
      |------------------------------------------------------------|---|
      |Serializable| 원격으로 객체를 전송하거나, 파일에 저장할 수 있음을 지정                           |
      |Clonable| Object 클래스의 Clone() 메서드가 제대로 수행될 수 있음을 지정 즉, 복제가 가능한 객체이다. |
      |Itrable<E>| 객체가 "foreach"문장을 사용할 수 있음을 지정.|
      |Collection<E>|여러 개의 객체를 하나의 객체에 담아 처리할 때의 메서드 지정|
      |Set<E>|셋 데이터를 처리하는 것과 관련된 메서드 지정|
  - Set은 순서가 없다. 순서가 매개 변수로 넘어가는 메서드나 수행 결과가 데이터의 위치와 관련된 메서드는 Set인터페이스에서는 필요가 없다.
  - get(int index), indexOf(Object o)와 같은 메서드들은 Set에 존재 하지 않는다.

### HashSet의 생성자들도 여러 종류가 있다.
- HashSet 클래스에는 다음과 같이 4개의 생성자가 존재한다.
  - |생성자|설명|
    |-----|----|
    |HashSet() |데이터를 저장할 수 있는 16개의 공간과 0.75의 로드 팩터(load factor)를 가즌 객체를 생성한다.|
    |HashSet(Collection<? extends E> c) |매개 변수로 받은 컬렉션 객체의 데이터를 HashSet에 담는다.|
    |HashSet(int initialCapacity)| 매개 변수로 받은 개수만큼의 데이터 저장 공간과 0.75의 로드 팩터를 갖는 객체를 생성한다.|
    |HashSet(int initialCapacity, float loadFactor)| 첫 매개 변수로 받은 개수만큼의 데이터 저장 공간과 두 번째 매개 변수로 받은 만큼의 로드팩터를 갖는 객체를 생성한다.|
- 로드팩터( load factor)? 
  - (데이터의 개수)/(저장공간)을 의미.
    - 데이터의 개수가 증가하여 로드팩터보다 커지면, 저장 공간의 크기는 증가되고 해시 재정리 작업을(rehash)을 해야만 한다.
      - 데이터가 해시 재정리 작업에 들어가면, 내부에 갖고 있는 자료 구조를 다시 생성하는 단계를 거쳐야 하므로 성능에 영향이 발생한다.
      - <b style="color:orange">로드 팩터라는 값이 클수록 공간은 넉넉해지지만, 데이터를 찾는 시간은 증가한다.</b>  
      따라서, 초기 공간 개수와 로드팩터는 데이터의 크기를 고려하여 산정하는 것이 좋다.  
      이유는 초기 크기가 (데이터의 개수)/(로드팩터)보다 클 경우에는 데이터를 쉽게 찾기 위한 해시 재정리 ㅈ가업이 발생하지 않기 때문이다.  
      따라서 대량의 데이터를 여기에 담아 처리할 때에는 초기 크기와 로드 팩터의 값을 조절해 가면서 가장 적당한 크기를 찾아야만 한다.  
      
    
