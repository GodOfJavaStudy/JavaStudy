# 4장 정보를 어디에 넣고 싶은데

### 변수란?
- ```variables```
- 어떤 상태가 변함을 담을 수 있는 매개체

## 자바의 변수 타입 4가지

### 1. 지역 변수
- ```local variables```
- 중괄호 내에서 선언 된 변수
- 지역 변수를 선언한 중괄호 내에서만 유효한다. 그 외 범위에서는 사용 불가

### 2. 매개 변수
- ```parameters```
- 메소드에 넘겨주는 변수
- 메소드가 호출 될 때 생명이 시작되고, 메소드가 끝나면 소멸된다. 즉, 해당 메소드에서만 사용 가능

### 3. 인스턴스 변수
- ```instance variables```
- 메소드 밖에, 클래스 안에 선언 된 변수, 앞에는 ```static```이라는 예약어가 없어야 한다.
- 객체가 생성 될 때 생명이 시작되고, 그 객체를 참조하고 있는 다른 객체가 없으면 소멸된다.

> ### 참고1) ```static``` 예약어가 없어야 하는 이유
> - 추 후 배우겠지만, ```static``` 예약어를 붙여서 변수를 생성할 경우 해당 변수는 자바 프로그램이 종료 될 때까지 메모리에 남아 있는다.
> - 그런데, 인스턴스 변수는 해당 클래스가 종료 될 경우 메모리에서 사라져야 하기 때문에 맞지 않는다. 그러므로, ```static```예약어는 없어야 한다.  

### 4. 클래스 변수
- ```class variables```
- 인스턴스 변수처럼 메소드 밖에, 클래스 안에 선언 된 변수 중에서 타입 선언 앞에 ```static```이라는 예약어가 있는 변수
- 클래스가 처음 호출 될 때 생명이 시작되고, 자바 프로그램이 끝날 때 소멸된다.

> ### 참고2) 예시로 알아보는 변수 타입
> ```java
> public class VariableTypes {
>   int instanceVariable;               //3. 인스턴스 변수
>   static int classVariable;           //4. 클래스 변수
>   public void method(int parameter) { //2. 매개 변수
>       int localVariable;              //1. 지역 변수
>   }
> }
> ```

> ### 참고3) ```가비지 콜렉터(Garbage collector)```
> - 자바는 ```C```나 ```C++```과 달리 한 변수에 저장한 값을, 자바 프로그램에서는 더 이상 사용이 안 된다 판단이 되면 메모리에서 해당 데이터를 소멸시켜준다.
> - 이를 ```가비지 콜렉터```라고 한다.
 
### 변수 명명 규칙
- 길이의 제한은 없다.
- 첫 문자는 유니코드 문자, 알파벳, ```$```(달러표시, dollar sign), ```_```(언더스코어, underscore)만 올 수 있다.
- 그러나, 일반적으로는 ```$```와 ```_```로 변수 이름을 시작하지 않는다.
- 보통은 메소드 이름처럼 지정해서 사용하며, 첫 문자는 소문자, 이어지는 단어의 첫번째 문자만 대문자로 해서 명명한다.
- 위와 같은 방식을 ```카멜케이스```라고 한다. ```ex) godOfJava```
- ```상수(constant value)```의 경우에는 모두 대문자로 지정하며, 단어와 단어 사이에는 ```_```로 구분을 한다. 여기서 상수라는 것은 절대 변하지 않는 값을 이야기한다. 따라서, 계속 값이 변하는 일반적인 변수는 ```_```를 붙이지 않는다.(물론, 회사 컨벤션에 따라 달라질 수 있다. 하지만 권장하지 않는다.)

> ### 참고4) 변수 명명 규칙 예제
> 1. godOfJava
> 2. BASIC_JAVA
> 3. godOfJava1
> 4. godOfJava2
> #### 틀리진 않았지만, 권장하지 않는 방식
> 1. $godOfJava
> 2. _god_of_java
> 3. god_of_java
> #### 틀린 방식
> 1. 8thBook(숫자는 절대로 맨 앞에 올 수 없다.)
 
## 자바의 두 가지 자료형

### 기본 자료형
- ```Primitive data type```
- 자바에서 기본적으로 정해진 자료형으로, 개발자가 임의로 추가해서 만들 수 없는 자료형
- ```new``` 예약어를 사용하지 않고 바로 초기화가 가능한 자료형
- ```ex) int a = 1;```

### 참조 자료형
- ```Reference data type```
- 개발자가 마음대로 만들 수 있는 자료형
- ```new``` 예약어를 사용해야만 초기화가 가능한 자료형
- ```ex) Car dogCar = new Car();```

> ### 참고5) 초기화란?
> - 변수를 선언할 때 해당 변수의 값을 넣어주는 것
 
### 예외적인 참조 자료형 ```String```
- ```String```은 예외적으로 기본 자료형, 참조 자료형 선언 방식으로 선언이 가능하다.
- ex)
```java
String bookName1 = "God Of Java";   //기본 자료형 선언 방식

String bookName2 = new String("God Of Java");   //참조 자료형 선언 방식
```
- ```String```클래스에 대한 자세한 내용은 뒷 장에서 배울 수 있다.

## 기본 자료형 8가지

### 정수형
|타입| 최소                                   | 최대                                   |
|---|--------------------------------------|--------------------------------------|
|byte| \-128(2의 7제곱)                        | 127(2의 7제곱-1)                        |
|short| \-32,768(2의 15제곱)                    | 32,767(2의 15제곱-1)                    |
|int| \-2,147,483,648(2의 31제곱)             | 2,147,483,647(2의 31제곱-1)             |
|long| \-9,223,372,036,854,775,808(2의 63제곱) | 9,223,372,036,854,775,807(2의 63제곱-1) |
|char| 0('\u0000')(0)                       | 65,535('\uffff')(2의 16제곱-1)          |
 
### 소수형
1. float
2. double

### 기타
1. boolean

### 정수형 타입의 범위
- 정수형 타입들은 각각 8비트(`byte`), 16비트(`short`), 32비트(`int`), 64비트(`long`)의 비트로 되어있다.
- 정수형 타입의 범위를 구하는 방법은 양수에서는 (비트값 -1)만큼 2의 제곱을 하고 나온 결과값에서 -1을 하면 되고, 음수 같은 경우는 양수와 동일하나 결과값에 1을 빼지 않고 -1을 곱한다.
- ex) byte 기준 
  - 양수 : (2의 (8(비트) - 1)승 -1)
  - 음수 : -1 * (2의 (8(비트) - 1))
- 그런데 정확한 계산 방법은 아래와 같다.
- 컴퓨터는 숫자를 0과 1밖에 모르기 때문에, 2진수로 표현을 한다.
- 그래서, byte 즉 8비트의 표현은 아래와 같이 표현할 수 있으며, 계산 방식은 1이 있는 값의 2의 n승을 구하여 다 합치면 결과가 나온다.
- 양수 : 0111 1111
- 음수 : 1000 0000
- 위처럼 양수, 음수가 모두 있는 표현식은 `signed`타입이라고 하고, 만약에 양수만 존재하는 타입의 경우는 `unsigned` 타입이라고 부른다.
- `unsigned`타입을 쓰는 이유는 해당 정수형 타입을 사용하는 필드가 음수가 존재하지 않는 값이고, 최대한 많은 값을 담기 위해서이다.
- 음수를 사용하지 않기 때문에, `unsigned` 타입의 최대 값은 (2의 (비트수) 승 - 1) 이 된다.
- byte 기준 범위
- `signed` : -128~127
- `unsigned` : 0~255

> ### 참고6) byte 기준으로 보는 비트 표현 식
>  단위 : 2의 n승 | 7   | 6   | 5   | 4   | 3   | 2   | 1   | 0   |
> ------------|-----|-----|-----|-----|-----|-----|-----|-----|
>  양수         | 0   | 1   | 1   | 1   | 1   | 1   | 1   | 1   |
>  음수 | 1 | 0 | 0 | 0 | 0 |0 |0 |0|

> ### 참고7) 2진수 계산
> - byte의 최소값은 -128이고, 최대값은 127이다.
> - 여기서 만약, 최소값에서 1을 빼거나 최대값에서 1을 더하면 어떻게 될까?
> - 일반적인 10진수 계산법에서는 에러가 날 것이다.
> - 그러나 만약 2진수로 변형해서 계산을 하면, -128에서 1을 뺀 값은 127이 되고, 127에서 1을 더한 값은 -128이 된다.
> - 이러한 일이 일어나는 이유는, 2진수로 변형을 경우 -128은 `1000 000`이고 127은 `0111 1111`이다.
> - 이제 byte 2진수 최소값에 1을 뺄 경우 값은 `0111 1111`이 된다. 이러한 값은, 위에 본 127의 2진수 변형 값과 동일하므로 다시 10진수로 변형 시 127이 되는 것이다.
> - 위와 동일한 이유로, byte 2진수 최대값 `0111 1111`에 1을 더할 경우 `1000 0000`이 되므로, 해당 값은 -127이 되는 것이다.
 
### `int`와 `long`
- 일반적으로, 정수형들은 `byte`나 `short`보다 `int`와 `long`을 많이 쓴다.
- 왜냐하면, 계산을 목적으로 `byte`나 `short`를 사용할 경우 계산할 수 있는 값이 많이 적어, 에러를 발생할 수 있기 때문이다.
- 데이터의 값이 많이 클 것 같은 경우는 `int`가 아닌 `long`을 사용하고, `long`을 사용하기 위해서는 숫자뒤에 `L`을 붙여줘야 한다.
- 만약 `L`을 붙이지 않으면 해당 값은 `int` 타입으로 인식 되어 컴파일 시 에러가 난다.
- ex)
- `long value = 10;` : 에러
- `long value = 10L;` : 뒤에 `L`을 붙였으므로, `long` 타입으로 인식하여, 정상적으로 컴파일 된다.

### 소수점을 처리하기 위한 타입들
- 소수점을 처리하기 위해서는 실수형 타입인 `float(32비트)`와 `double(64비트)` 타입이 사용 된다.
- 그러나, 정확한 데이터 계산이 필요할 경우(예를 들면 돈 계산 같은 경우) 위의 두 타입을 사용하면 안 되는데 왜냐하면 해당 비트로 제공할 수 있는 범위를 넘어서면 그 값의 정확성을 보장하지 못하기 때문이다.
- 그럴 경우 `java.math.BigDecimal`이라는 클래스를 이용하면 된다. 이것에 관한 내용은 추 후 나온다.

### `char`
- `char`는 보통 문자열과 관련된 부분에서 사용하며, 초기화 할 때는 홑따옴표를 사용한다.
- ex)
- `char c = "C";` : 에러
- `char c = 'C';` : 정상적으로 컴파일
- 

### `boolean`
- `true`와 `false` 두 개의 값만 들어가있는 자료형이다.

### 기본 자료형의 기본 값
- 기본적으로 `지역 변수`들은 값을 할당 즉, 초기화를 하지 않으면 컴파일 시 에러가 난다.
- 하지만, 기본 자료형 같은 경우는 기본 값이 있기 때문에, 초기화를 하지 않아도 에러가 나지 않는다.
- 다만, 선언을 할 경우에는 문제가 없지만 해당 자료형을 사용 할 경우는 에러가 난다.
- 그러나, `클래스 변수`, `인스턴스 변수` 같은 경우는 선언만 해도 기본 값으로 사용 가능하다.

> ### 참고 8) 기본 자료형의 기본 값
> 타입|기본 값|
> ---|---|
> byte|0|
> short|0|
> int|0|
> long|0|
> float|0.0|
> double|0.0|
> char|(공백)|
> boolean|false|